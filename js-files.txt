--- FILE: frontend\eslint.config.js ---
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...reactHooks.configs.recommended.rules,
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]


--- FILE: frontend\src\App.jsx ---
import { useState, useEffect } from 'react';
import Joyride from 'react-joyride';

import { useWhatsAppActions } from './hooks/useWhatsAppActions';
import { useTourSteps } from './tour/useTourSteps';

import Header from './components/Header';
import ActionButtons from './components/ActionButtons';
import QRSection from './components/QRSection';
import StatusBanner from './components/StatusBanner';
import ContactTable from './components/ContactTable';

function App() {
  const [contacts, setContacts] = useState([]);
  const [qrCode, setQrCode] = useState(null);
  const [status, setStatus] = useState('initial');

  const { syncWhatsApp, loadContacts, resetContacts, loading } =
    useWhatsAppActions(setContacts, setQrCode, setStatus);
  const { steps, runTour, setRunTour } = useTourSteps();

  useEffect(() => {
    const source = new EventSource(`${import.meta.env.VITE_API_BASE_URL}/api/whatsapp/events`);
    source.addEventListener('qr', (e) => {
      const { qr } = JSON.parse(e.data);
      setQrCode(qr);
      setStatus('waiting-qr');
    });
    source.addEventListener('ready', () => {
      setQrCode(null);
      setStatus('ready');
    });
    return () => source.close();
  }, []);

  return (
    <div className="p-4 w-full mx-auto">
      <Joyride
        steps={steps}
        run={runTour}
        continuous
        showProgress
        showSkipButton
        styles={{ options: { zIndex: 9999 } }}
        callback={(data) => {
          if (['finished', 'skipped'].includes(data.status)) setRunTour(false);
        }}
      />

      <div className="flex justify-between items-center mb-4">
        <Header />
        <button onClick={() => setRunTour(true)} className="text-sm bg-gray-200 px-3 py-1 rounded">
          ‚ùì Help / Tour
        </button>
      </div>

      <ActionButtons
        onSync={syncWhatsApp}
        onLoad={loadContacts}
        onReset={resetContacts}
        loading={loading}
      />

      <QRSection status={status} qrCode={qrCode} />
      <StatusBanner status={status} />
      <ContactTable contacts={contacts} loading={loading} />
    </div>
  );
}

export default App;


--- FILE: frontend\src\components\ActionButtons.jsx ---
import { QrCodeIcon, UserGroupIcon, TrashIcon } from '@heroicons/react/24/outline';


export default function ActionButtons({ onSync, onLoad, onReset, loading }) {
  return (
    <div className="flex gap-4 justify-center mb-6">
      <button
        onClick={onSync}
        disabled={loading}
        className="sync-button flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        <QrCodeIcon className="w-5 h-5" />
        Sync WhatsApp
      </button>

      <button
        onClick={onLoad}
        disabled={loading}
        className="load-button flex items-center gap-2 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        <UserGroupIcon className="w-5 h-5" />
        Load Contacts
      </button>

      <button
        onClick={onReset}
        disabled={loading}
        className="reset-button flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded disabled:opacity-50"
      >
        <TrashIcon className="w-5 h-5" />
        Reset All
      </button>
    </div>
  );
}


--- FILE: frontend\src\components\ContactTable.jsx ---
import { useState } from 'react';
import { PhoneIcon, ChatBubbleLeftEllipsisIcon } from '@heroicons/react/24/solid';

export default function ContactTable({ contacts, loading }) {
  const [sortBy, setSortBy] = useState('last_message_date');
  const [sortAsc, setSortAsc] = useState(false);

  if (loading) {
    return (
      <div className=" contacts-table text-center py-10 text-gray-500 animate-pulse">
        <svg className="mx-auto h-10 w-10 animate-spin text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4l3.5-3.5L12 0v4a8 8 0 00-8 8z"></path>
        </svg>
        <p>Loading contacts‚Ä¶</p>
      </div>
    );
  }
  
  if (contacts.length === 0) return <p className='contacts-table '>No contacts found.</p>;

  const sortedContacts = [...contacts].sort((a, b) => {
    const aVal = a[sortBy];
    const bVal = b[sortBy];
  
    if (sortBy === 'message_count') {
      return sortAsc ? (aVal - bVal) : (bVal - aVal);
    }
  
    if (sortBy === 'last_message_date') {
      const aDate = new Date(aVal || 0).getTime();
      const bDate = new Date(bVal || 0).getTime();
      return sortAsc ? (aDate - bDate) : (bDate - aDate);
    }
  
    // Default: string comparison
    return sortAsc
      ? String(aVal || '').localeCompare(String(bVal || ''))
      : String(bVal || '').localeCompare(String(aVal || ''));
  });
  
  const handleSort = (column) => {
    setSortBy(column);
    setSortAsc(sortBy === column ? !sortAsc : true);
  };

  return (
    <div className="contacts-table mt-6 overflow-x-auto">
      <h2 className="text-lg font-semibold mb-3">Contacts</h2>
      <table className="min-w-full border border-gray-300 rounded-md overflow-hidden shadow-sm">
        <thead className="bg-gray-100 text-gray-700">
          <tr>
            <th className="text-left px-4 py-2">#</th>
            <th className="text-left px-4 py-2 cursor-pointer" onClick={() => handleSort('name')}>
              Name {sortBy === 'name' ? (sortAsc ? '‚ñ≤' : '‚ñº') : ''}
            </th>
            <th className="text-left px-4 py-2 cursor-pointer" onClick={() => handleSort('phone')}>
              <div className="flex items-center gap-1">
                <PhoneIcon className="w-4 h-4 text-gray-600" />
                Phone {sortBy === 'phone' ? (sortAsc ? '‚ñ≤' : '‚ñº') : ''}
              </div>
            </th>
            <th className="text-left px-4 py-2 cursor-pointer" onClick={() => handleSort('message_count')}>
              <div className="flex items-center gap-1">
                <ChatBubbleLeftEllipsisIcon className="w-4 h-4 text-gray-600" />
                Total Messages {sortBy === 'message_count' ? (sortAsc ? '‚ñ≤' : '‚ñº') : ''}
              </div>
            </th>
            <th className="text-left px-4 py-2 cursor-pointer" onClick={() => handleSort('last_message_date')}>
              Last Message {sortBy === 'last_message_date' ? (sortAsc ? '‚ñ≤' : '‚ñº') : ''}
            </th>
          </tr>
        </thead>
        <tbody>
          {sortedContacts.map((contact, index) => (
            <tr key={index} className="border-t">
              <td className="px-4 py-2">{index + 1}</td>
              <td className="px-4 py-2">{contact.name}</td>
              <td className="px-4 py-2">{contact.phone}</td>
              <td className="px-4 py-2 text-center">{contact.message_count ?? 0}</td>
              <td className="px-4 py-2">{contact.last_message_date ? new Date(contact.last_message_date).toLocaleString() : '‚Äî'}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}


--- FILE: frontend\src\components\Header.jsx ---
export default function Header() {
    return (
      <h1 className="text-2xl font-bold mb-6 text-center">üì± WhatsApp Contact Sync</h1>
    );
  }
  

--- FILE: frontend\src\components\QRSection.jsx ---
export default function QRSection({ status, qrCode }) {
    if (status !== 'waiting-qr') return null;
  
    return (
      <div className="text-center">
        <p className="mb-2 font-medium text-gray-700">Scan this QR code with WhatsApp:</p>
        {qrCode ? (
          <img src={qrCode} alt="QR Code" className="mx-auto w-64 h-64 border" />
        ) : (
          <p>Generating QR code...</p>
        )}
      </div>
    );
  }
  

--- FILE: frontend\src\components\StatusBanner.jsx ---
export default function StatusBanner({ status }) {
  if (status !== 'ready') return null;

  return (
    <div className="status-banner text-center text-green-700 font-semibold mb-4">
      ‚úÖ WhatsApp is connected and ready!
    </div>
  );
}


--- FILE: frontend\src\hooks\useWhatsAppActions.js ---
import { useState } from 'react';
import Swal from 'sweetalert2';
import axios from '../services/api';

export function useWhatsAppActions(setContacts, setQrCode, setStatus) {
  const [loading, setLoading] = useState(false);

  const syncWhatsApp = async () => {
    try {
      setLoading(true);
      const { data } = await axios.get('/whatsapp/status');
  
      if (data.ready) {
        const confirm = await Swal.fire({
          title: 'WhatsApp is already connected',
          text: 'Do you want to regenerate a new QR code (you‚Äôll be logged out)?',
          icon: 'question',
          showCancelButton: true,
        });
  
        if (!confirm.isConfirmed) return;
  
        await axios.post('/whatsapp/restart'); // <-- for√ßar reinicializa√ß√£o
        setContacts([]);
        setStatus('initial');
      }
  
      setQrCode(null); // frontend limpa o QR anterior
      setStatus('waiting-qr');
  
      Swal.fire({
        icon: 'info',
        title: 'Waiting for QR code',
        toast: true,
        showConfirmButton: false,
        timer: 3000,
      });
    } catch (err) {
      console.error(err);
      Swal.fire({ icon: 'error', title: 'Sync failed' });
    } finally {
      setLoading(false);
    }
  };
  
  const loadContacts = async () => {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000);
  
    try {
      setLoading(true);
      const { data: status } = await axios.get('/whatsapp/status', { signal: controller.signal });
      if (!status.ready) {
        Swal.fire({ icon: 'warning', title: 'WhatsApp not connected' });
        return;
      }
  
      const { data } = await axios.get('/contacts', { signal: controller.signal });
  
      setContacts(data.contacts);
  
      Swal.fire({
        icon: 'success',
        title: 'Contacts loaded',
        toast: true,
        timer: 2000,
      });
    } catch (err) {
      if (err.name === 'CanceledError') {
        // Show partial data (if any), no modal
        Swal.fire({
          icon: 'warning',
          title: 'Timeout',
          text: 'Some contacts may be missing due to timeout.',
          toast: true,
          timer: 3000,
        });
      } else {
        Swal.fire({
          icon: 'error',
          title: 'Error loading contacts',
          text: err.message,
        });
      }
    } finally {
      clearTimeout(timeout);
      setLoading(false);
    }
  };
  

  const resetContacts = async () => {
    const confirm = await Swal.fire({
      title: 'Reset everything?',
      icon: 'warning',
      showCancelButton: true,
    });

    if (!confirm.isConfirmed) return;

    try {
      setLoading(true);
      await axios.delete('/contacts/reset');
      setContacts([]);
      setStatus('initial');
      Swal.fire({ icon: 'success', title: 'Reset complete', toast: true, timer: 2000 });
    } catch (err) {
      Swal.fire({ icon: 'error', title: 'Reset failed '+err.message });
    } finally {
      setLoading(false);
    }
  };

  return { syncWhatsApp, loadContacts, resetContacts, loading };
}


--- FILE: frontend\src\main.jsx ---
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


--- FILE: frontend\src\services\api.js ---
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

const instance = axios.create({
  baseURL: `${API_BASE_URL}/api`,
  timeout: 30000,
});

export default instance;


--- FILE: frontend\src\tour\useTourSteps.js ---
import { useState } from 'react';

export function useTourSteps() {
  const [runTour, setRunTour] = useState(false);

  const steps = [
    { target: '.sync-button', content: 'Click here to sync WhatsApp.' },
    { target: '.load-button', content: 'Click to load your contacts.' },
    { target: '.reset-button', content: 'This resets everything.' },
    { target: '.status-banner', content: 'Shows WhatsApp connection status.' },
  ];

  return { steps, runTour, setRunTour };
}


--- FILE: frontend\vite.config.js ---
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react-swc'
import tailwindcss from '@tailwindcss/vite'
import process from 'process'

export default defineConfig(({ mode }) => {
  // Carregar as vari√°veis de ambiente corretamente
  const env = loadEnv(mode, process.cwd(), '')
  return {
    plugins: [
      react(),
      tailwindcss(),
    ],
    server: {
      // allowedHosts: ['ticket-system.danielneto.com'],
      host: true,  
      port: parseInt(env.VITE_PORT) || 5001, // Usando a vari√°vel carregada do .env
    },
  }
})


--- FILE: backend\controllers\contactsController.js ---
import { getDB } from '../services/db.js';
import {
  getInstance as getClient,
  getClientStatus,
  reinitializeClient,
  setClientReady,
} from '../services/whatsappService.js';

import fs from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

export async function listContacts(req, res) {
  const db = await getDB();
  let contacts = await db.all(`SELECT * FROM contacts ORDER BY last_message_date DESC`);

  if (contacts.length === 0) {
    await syncContacts(); // sync if empty
    contacts = await db.all(`SELECT * FROM contacts ORDER BY last_message_date DESC`);
  }

  res.json({ contacts });
}

export async function resetContacts(req, res) {
  try {
    const db = await getDB();
    await db.exec('DELETE FROM contacts');

    const client = getClient();
    if (client) {
      try {
        await client.destroy(); // must fully release files
        setClientReady(false);
        console.log('üõë WhatsApp client destroyed');
      } catch (err) {
        console.warn('‚ö†Ô∏è Failed to destroy client:', err.message);
      }
    }

    const sessionDir = resolve(__dirname, '../.wwebjs_auth');
    if (fs.existsSync(sessionDir)) {
      try {
        fs.rmSync(sessionDir, { recursive: true, force: true });
        console.log('üóëÔ∏è WhatsApp session removed');
      } catch (err) {
        if (err.code === 'EBUSY') {
          console.warn(`‚ö†Ô∏è Could not delete session files: ${err.path}`);
        } else {
          throw err;
        }
      }
    }

    await reinitializeClient(); // force new QR
    res.json({ success: true });
  } catch (err) {
    console.error('Failed to reset:', err);
    res.status(500).json({ error: 'Failed to reset' });
  }
}

export async function syncContacts(req, res = null) {
  const isReady = getClientStatus();
  if (!isReady) {
    const message = 'WhatsApp client is not ready';
    console.warn(message);
    if (res) return res.status(503).json({ error: message });
    else throw new Error(message);
  }

  const db = await getDB();
  const client = getClient();
  const contacts = await client.getContacts();

  await db.exec('DELETE FROM contacts');

  for (const contact of contacts) {
    if (!contact.isUser) continue;
    try {
      const chat = await contact.getChat();
      if (!chat) continue;
      const messages = await chat.fetchMessages({ limit: 100 });

      await db.run(
        `INSERT INTO contacts (name, phone, last_message_date, message_count)
         VALUES (?, ?, ?, ?)`,
        [
          contact.name || contact.pushname || contact.number,
          contact.number,
          messages[0]?.timestamp
            ? new Date(messages[0].timestamp * 1000).toISOString()
            : null,
          messages.length,
        ]
      );
    } catch (err) {
      console.warn('‚ö†Ô∏è Failed contact:', contact.number, err.message);
    }
  }

  if (res) res.json({ success: true });
}


--- FILE: backend\db\index.js ---


--- FILE: backend\init-db.js ---
import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import { resolve } from 'path';

const init = async () => {
    const db = await open({
        filename: resolve(__dirname, 'db', 'contacts.db'),
        driver: sqlite3.Database
    });

    await db.exec(`
    CREATE TABLE IF NOT EXISTS contacts (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT,
      phone TEXT,
      last_message_date TEXT,
      message_count INTEGER
    );
  `);

    console.log('Database initialized');
};

init();


--- FILE: backend\routes\contacts.js ---
import express from 'express';
import {
  listContacts,
  syncContacts,
  resetContacts,
} from '../controllers/contactsController.js';

const router = express.Router();

// GET /api/contacts
router.get('/', listContacts);

// POST /api/contacts/sync
router.post('/sync', syncContacts);

// DELETE /api/contacts/reset
router.delete('/reset', resetContacts);

export default router;


--- FILE: backend\routes\whatsapp.js ---
import express from 'express';
import {
  getLatestQR,
  getClientStatus,
  getInstance as getClient,
  reinitializeClient,
} from '../services/whatsappService.js';

const router = express.Router();

// GET /api/whatsapp/qr
router.get('/qr', (req, res) => {
  const qrCode = getLatestQR();
  if (qrCode) {
    res.json({ qr: qrCode });
  } else {
    res.status(204).json({ message: 'No QR code available' });
  }
});

// GET /api/whatsapp/status
router.get('/status', (req, res) => {
  const ready = getClientStatus();
  res.json({ ready });
});

// GET /api/whatsapp/client-info
router.get('/client-info', async (req, res) => {
  try {
    const client = getClient();
    const info = await client.info;
    res.json({
      pushname: info.pushname,
      wid: info.wid,
      platform: info.platform,
    });
  } catch (err) {
    console.error('Error getting client info:', err);
    res.status(500).json({ error: 'Failed to get client info' });
  }
});

router.post('/restart', async (req, res) => {
  await reinitializeClient();
  res.json({ success: true });
});

// Optional: re-sync route here if needed
// router.post('/sync', syncContacts);

export default router;


--- FILE: backend\routes\whatsappEvents.js ---
import express from 'express';
import { getClientStatus, getLatestQR } from '../services/whatsappService.js';

const router = express.Router();

let clients = [];

router.get('/events', (req, res) => {
  res.set({
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
  });

  res.flushHeaders();

  const client = { res };
  clients.push(client);

  req.on('close', () => {
    clients = clients.filter((c) => c !== client);
  });

  // Send initial QR and status
  const qr = getLatestQR();
  if (qr) res.write(`event: qr\ndata: ${JSON.stringify({ qr })}\n\n`);

  if (getClientStatus()) {
    res.write(`event: ready\ndata: {}\n\n`);
  }
});

export function broadcastEvent(event, data) {
  const payload = `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
  clients.forEach((client) => client.res.write(payload));
}

export default router;


--- FILE: backend\server.js ---
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import contactsRoutes from './routes/contacts.js';
import whatsappRoutes from './routes/whatsapp.js';
import whatsappEventRoutes from './routes/whatsappEvents.js';

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

// Route namespaces
app.use('/api/contacts', contactsRoutes);
app.use('/api/whatsapp', whatsappRoutes);
app.use('/api/whatsapp', whatsappEventRoutes);

const PORT = process.env.BACKEND_PORT || 4000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});


--- FILE: backend\services\db.js ---
import { open } from 'sqlite';
import sqlite3 from 'sqlite3';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));

export const getDB = async () => {
  return open({
    filename: resolve(__dirname, '../db/contacts.db'),
    driver: sqlite3.Database,
  });
};


--- FILE: backend\services\whatsappService.js ---
import fs from 'fs';
import path, { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import pkg from 'whatsapp-web.js';
import qrcode from 'qrcode';
import { broadcastEvent } from '../routes/whatsappEvents.js';

const { Client, LocalAuth } = pkg;
const __dirname = dirname(fileURLToPath(import.meta.url));
const sessionDir = resolve(__dirname, '../.wwebjs_auth');

// Ignore busy log file
const originalUnlinkSync = fs.unlinkSync;
fs.unlinkSync = function (targetPath) {
  if (targetPath.includes('chrome_debug.log')) {
    try { originalUnlinkSync(targetPath); } 
    catch (e) {
      if (e.code === 'EBUSY') {
        console.warn(`‚ö†Ô∏è Ignoring busy file: ${targetPath}`);
        return;
      }
      throw e;
    }
  } else {
    return originalUnlinkSync(targetPath);
  }
};

let clientInstance = null;
let latestQR = null;
let isClientReady = false;

function createClient() {
  const client = new Client({
    authStrategy: new LocalAuth(),
    puppeteer: { headless: true },
  });

  client.on('qr', async (qr) => {
    latestQR = await qrcode.toDataURL(qr);
    console.log('üîÑ QR code generated');
    broadcastEvent('qr', { qr: latestQR });
  });
  
  client.on('ready', () => {
    isClientReady = true;
    console.log('‚úÖ WhatsApp client is ready!');
    broadcastEvent('ready', {});
  });
  

  client.on('authenticated', () => {
    console.log('üîê Authenticated with WhatsApp.');
  });

  client.on('auth_failure', (msg) => {
    isClientReady = false;
    console.error('‚ùå Authentication failed:', msg);
  });

  client.initialize();
  clientInstance = client;
}

async function reinitializeClient() {
  console.log('‚ôªÔ∏è Reinitializing WhatsApp client...');
  isClientReady = false;
  latestQR = null;

  if (clientInstance) {
    try {
      await clientInstance.destroy(); // important!
      console.log('üõë Previous client destroyed.');
    } catch (err) {
      console.warn('‚ö†Ô∏è Error destroying client:', err.message);
    }
  }

  try {
    if (fs.existsSync(sessionDir)) {
      fs.rmSync(sessionDir, { recursive: true, force: true });
      console.log('üóëÔ∏è .wwebjs_auth folder deleted');
    }
  } catch (err) {
    console.error('Failed to delete session folder:', err.message);
  }

  createClient();
}


function getInstance() {
  return clientInstance;
}

function getLatestQR() {
  return latestQR;
}

function getClientStatus() {
  return isClientReady;
}

function setClientReady(state) {
  isClientReady = state;
}

createClient(); // start on load

export {
  getInstance,
  getLatestQR,
  getClientStatus,
  setClientReady,
  reinitializeClient,
};

